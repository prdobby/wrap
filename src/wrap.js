/**
 * Allows the user to wrap a series of files with a template. The template
 * file should use the string @@@@FILE@@@@ to indicate where each file's contents
 * should be located.
 *
 * @import bluebird (Promise) - allows use of promises and converting libraries
 * to promises
 * @import fs-extra (fs) - utility for accessing the files to wrap. Used in place
 * of fs because native fs cannot ensure a directory exists without an error.
 * @import glob (parser) - allows for glob parsing if not used as a command-line
 * utility
 *
 * @var FILE_OPTS - specifies the default file options that allow for regex
 * @var PARSE_OPTS - specifies parser options so that it doesn't return
 * directories
 * @var outputSpecified - boolean to indicate if the outputDir is specified 
 * because that alters a lot of operations
 *
 * @author prdobby
 */
var Promise = require('bluebird'),
		fs = Promise.promisifyAll(require('fs-extra')),
		parser = Promise.promisify(require('glob')),
		FILE_OPTS = {"encoding": "utf-8"},
		PARSE_OPTS = {"nodir": true},
		outputSpecified;

/**
 * Wraps the given files with the template file provided and writes
 * them to a directory.
 *
 * @exports
 * @param options
 *   @prop sources - a string or array that indicates what files to wrap. Can
 *   use globs
 *   @prop destination - the output directory to place the wrapped files in.
 *   Defaults to the current directory ("./")
 *   @prop template - the template file used for wrapping the files
 */
function wrap(options) {
	/**
	 * @var promises - array to hold all the promises that must be satisfied
	 * before starting the processing
	 * @var errorHandler - the function that will be called on an error. Passed
	 * err object
	 * @var template - will hold the contents of the template file. Needs to be
	 * closure
	 */
	var promises = [],
			errorHandler = options.errorHandler || error,
			template;

	//Error checking to ensure required values are provided
	if (!options.sources) {
		throw new Error("Source files must be provided");
	}
	if (!options.template) {
		throw new Error("Template must be provided");
	}
	//Updates global variable so other functions can use it
	outputSpecified = options.destination !== undefined;

	//Creates the output directory if it doesn't exist
	if (outputSpecified) {
		promises.push(fs.ensureDirAsync(options.destination));
	}

	//Adds glob parsing promise for each source string given
	if (options.sources.constructor === Array) {
		options.sources.forEach(function(source) {
			promises.push(parser(source, PARSE_OPTS));
		});
	} else {
		promises.push(parser(options.sources, PARSE_OPTS));
	}

	/*
	 * Adds promise for reading template file into string. Purposefully doesn't
	 * return anything so that a later promise doesn't attempt to read the
	 * template file again.
	 */
	promises.push(
			loadFile(options.template)
			.then(function(temp) { 
				template= temp; 
			}));

	/*
	 * Promise chain to actually perform the wrapping. Map function has to be
	 * a nested function so that template is defined before being bound. Using
	 * wrapFile.bind(null, template) resulted in undefined being bound since
	 * template is undefined until the promise above is resolved.
	 */
	Promise.
		all(promises).
		then(flatten).
		then(readFiles).
		map(function(file) {
			return wrapFile(template, file);
		}).
		each(writeFile.bind(null, options.destination)).
		catch(errorHandler);
}

/*
 * The result of the Promise.all might be an array of arrays, so this flattens
 * them into a one-dimensional array. The first value is unshifted if the output
 * directory is defined because of the ensureDir promise above.
 *
 * @param arrs array of file name arrays generated by globs
 * @return array of file names
 */
function flatten(arrs) {
	if (outputSpecified) {
		arrs.shift();
	}
	return arrs.reduce(function(newArr, arr) {
		return newArr.concat(arr || []);
	}, []);
}

/**
 * Opens a file and returns a promise that will be resolved with the
 * file's contents
 * 
 * @param templateFile name of the file to open
 * @return promise resolved with file contents
 */
function loadFile(templateFile) {
	return fs.readFileAsync(templateFile, FILE_OPTS);
}

/**
 * Transforms an array of filenames into an array of objects, each
 * with the file's name and contents.
 *
 * @param files array of file names
 * @return promise resolved with array of file objects
 */
function readFiles(files) {
	return files.reduce(function(arr, file) {
		arr.push(loadFile(file).then(mapFile.bind(null, file)));
		return arr;
	}, []);
}

/**
 * Transforms the given parameters into a single object that can be used to
 * resolve a promise.
 * 
 * @param name of the file
 * @param contents of the file
 * @return map of file name and contents
 */
function mapFile(name, contents) {
	return {
		"name": name,
		"contents": contents
	};
}

/**
 * Inserts the file string into the template string in place of the @@@@FILE@@@@
 * string.
 *
 * @param template string that contains @@@@FILE@@@@ and will wrap the file
 * @param file the string contents of a file to be wrapped
 * @return string containing the wrapped file
 */
function wrapFile(template, file) {
	file.contents = template.replace(/@@@@FILE@@@@/, file.contents);
	return file;
}

/**
 * Writes the file to the destination directory. The file will have the same name
 * it had previously, but the directory structure will be flattened.
 *
 * @param dest the destination directory
 * @param file the file object containing its contents and name
 * @return promise resolved from writing to a file
 */
function writeFile(dest, file) {
	dest = (dest || ".") + "/" + /\w+\.?\w+$/.exec(file.name).pop();
	return fs.writeFileAsync(dest, file.contents, FILE_OPTS);
}

/**
 * Default error handler if none is specified. Just prints to console.
 */
function error(err) {
	console.error(err.stack);
}

module.exports = wrap;
